# Changelog

### Added
- **History Parser v0.4 Dependency Integration** - Integrated production-grade parsing dependencies with graceful fallbacks: (1) dateparser for flexible date normalization - handles ISO, natural language, and numeric formats in parse_ledger_sessions(); (2) rapidfuzz for fuzzy entity deduplication - removes near-duplicates (85% threshold), normalizes "The X" variants, case-insensitive matching in classify_entities(). All dependencies include fallback implementations if imports unavailable. Added requirements: markdown-it-py>=3.0.0, dateparser>=1.2.0, rapidfuzz>=3.5.0. Test Results: 10/10 parser tests passing. Lays foundation for Phase 3 (inline promote/demote controls) and Phase 4 (persistent import overrides). See docs/REQUIREMENTS_robust_history_parser.md for complete implementation plan. (commit 9292198)

### Added
- **History Parser v0.3 Polish Pass** - Four key quality improvements to campaign history import based on real-world Spelljammer file testing: (1) Ledger field separation - session titles now clean without bullet pollution, bullets extracted to separate structured field with multi-line handling; (2) Structured canon synthesis - subsection-aware extraction targeting Premise (1-2 bullets), Key NPCs/Powers (2-3), Major Artifacts (2-3), Current Situation (1-2), party roster collapsed to single line, total 8-12 bullets; (3) Faction cleanup - filters section headers (Future Sessions), removes arc markers (Spiral, Projected), normalizes "The " prefix, case-insensitive deduplication; (4) Artifact extraction - parses Major Artifacts section for "The X:", "X's Ring:", "Device of Y" patterns, integrates into entity classification. Test suite expanded to 10 comprehensive tests validating clean titles, structured canon, faction normalization, artifact detection. All acceptance criteria met: sessions 0-10 with clean titles, canon includes subsection diversity, factions list excludes false positives, artifacts include Chronolens. Tests: 10/10 parser + 88/88 full suite passing. (commit cc615cd)

### Added
- **Section-Aware History Parser v0.2** - Complete rewrite of campaign history parser with section-aware parsing and entity classification. Parser now respects document structure (splits by ## headings), extracts canon only from Canon Summary section (no bleed from ledger/notes), parses sessions from Campaign Ledger section using actual YYYY-MM-DD dates (not line numbers), classifies entities as factions vs places vs artifacts vs concepts, and parses Future Sessions and Open Threads into separate buckets (not added to ledger/canon). UI preview shows entities categorized, future sessions, and open threads in dedicated expanders. JSON export includes full parsed structure. Added comprehensive test suite (`tests/test_history_parser_spelljammer.py`) with 7 tests validating section isolation, entity classification, and proper handling of structured documents. Fixes: Canon Summary pollution, session date confusion, faction over-classification, future content bleed. All tests passing (85/85 suite + 7/7 parser tests). (commit 77896c5)

### Added
- **Campaign System Documentation Suite** - Created comprehensive documentation for Campaign Mechanics v0.2 and Integration Flows A-D. Added `docs/PLAY_GUIDE_campaigns.md` (user-facing guide covering campaign creation, session finalization, history import workflows, tips and troubleshooting) and `docs/ARCH_campaign_integration.md` (technical architecture detailing data models, flow patterns, persistence layer, design decisions, and testing strategy). Updated `docs/KEY_DOCS.md` to include campaign documentation in governance structure. Documentation covers all four integration flows: Flow A (Context â†’ Generator), Flow B (Session Finalization), Flow C (Import to Existing Campaign), Flow D (Import to New Campaign). Complete with examples, edge cases, performance considerations, and extensibility points. (commit 81a212f)

### Added
- **Campaign Integration Flows B, C, D** - Completed remaining campaign integration workflows beyond Flow A. Flow B (Session Finalization): Three-step wizard (review complications â†’ record outcomes â†’ confirm) with SessionPacket derivation from generator results, advisory pressure/heat delta suggestions, structured scar creation (severity 1-5 with effect descriptions), and faction disposition updates. Flow C (Import to Existing Campaign): "Import" button on dashboard ledger, paste/parse/preview/merge workflow using heuristic history parser to detect dates, extract canon bullets, identify factions, non-destructive merge appending to existing state. Flow D (Import to New Campaign): "Import Campaign History" button on landing page, paste/parse/preview/create workflow creating new campaign from narrative text with parsed session structure, extracted canon, and initialized factions at neutral disposition. All flows implemented in `streamlit_harness/campaign_ui.py`, `streamlit_harness/session_packet.py`, and `streamlit_harness/history_parser.py` with complete error handling and user feedback. Flows validated with manual testing. See `docs/INTEGRATION_STATUS_flows_BCD.md` for implementation details. (commit af02212)

### Added
- **Campaign Context Bridge** - Connected Campaign Manager to Event Generator with Context Bundle system. When "Run Session" clicked from campaign, Event Generator pre-fills with campaign-derived tags (based on pressure/heat/scars/factions). Context Applied strip shows campaign name, bands, factions, sources with View (expand notes) and Disable (1-click toggle) buttons. Tags merged intelligently: context suggestions + defaults, deduplicated. Context persists across sessions, GM can override any time. Answers "Why does this event belong in my campaign?" Zero engine modifications. See `streamlit_harness/campaign_context.py`.

### Added
- **Campaign UX Prototype v0.1** - New Campaign Manager mode in Streamlit harness with multi-campaign management workflow. Features: (1) Campaign selector with cards showing pressure/heat bands and activity metrics, (2) Campaign dashboard with editable canon summary, structured scars list, factions board with attention/disposition, campaign ledger, and content sources management, (3) Session finalization wizard for recording "what happened" with 3 bullets, scar creation, and faction updates, (4) Persistent state in campaigns/*.json files. Content sources: Add/toggle external sources (metadata only, no parsing), built-in source always shown, active sources displayed in header and recorded in ledger. Achieves â‰¤4 click target for all core actions: open campaign (2 clicks), create campaign (3 clicks), finalize session (2 clicks + typing), add source (2 clicks). Mode toggle at app top preserves existing debug harness. Session workspace currently stub (points to scenario runner). Campaign history import mocked for v0.1. Zero modifications to spar_engine/* or spar_campaign/* files. See `docs/UX_NOTES_campaign_v0.1.md` for complete UX analysis, known pain points, and v0.2 recommendations.
- **Campaign Mechanics Layer v0.2** - Extended campaign mechanics with structured scars, faction tracking, and long-arc bands. Scars now use structured model (Scar dataclass) with category (physical/social/political/resource/reputation/environment), severity (low/medium/high), source, and notes fields. Scars persist permanently and influence scene setup (resourceâ†’attrition, reputationâ†’social_friction). Added FactionState tracking with attention (0-20 cap) and disposition (-2 hostile to +2 allied) that accumulates from visibility/social_friction tags when faction is present in scene. Added descriptive bands for pressure (stable/strained/volatile/critical) and heat (quiet/noticed/hunted/exposed) as derived state descriptors. Enhanced get_campaign_influence() with faction/scar-aware suggestions. Maintains v0.1 backward compatibility (string scars migrate to legacy field). Demo script (`examples/campaign_mechanics_v0.2_demo.py`) shows 8-scene campaign with 2 explicit scars persisting, 3 factions tracking attention, and bands providing human-readable state. All integration remains non-invasive and optional. Design principle: "Scene outcomes echo forward. Campaign mechanics remember what can't be undone." See `docs/REQUIREMENTS_campaign_mechanics_v0.2.md` for complete design.
- **Campaign Mechanics Layer v0.1** - New optional campaign-level state tracking module (`spar_campaign/`) that operates above SPAR Engine. Tracks long-term pressure (`campaign_pressure`) and external attention (`heat`) across multiple scenes. Pure functional design with immutable CampaignState model. Features: (1) CampaignDelta derives from scene outcomes (severity >5, cutoffs, visibility tags), (2) Explicit decay for aftermath/downtime moments, (3) get_campaign_influence() provides scene setup hints without modifying engine internals, (4) Caps prevent runaway escalation (pressure: 30, heat: 20), (5) Optional scars for permanent consequences. Integration is non-invasive: campaign suggests tags/rarity, scene setup decides. Demo script (`examples/campaign_mechanics_demo.py`) shows 6-scene campaign with heat accumulation 0â†’10, aftermath decay, and dynamic tag influence. No changes to spar_engine/* files. Design principle: "Scene mechanics create pressure. Campaign mechanics remember it." See `docs/REQUIREMENTS_campaign_mechanics_v0.1.md` for complete design.
- **Low-urgency Aftermath content expansion** - Added 7 new Aftermath-only entries to increase tonal diversity and reduce time_pressure dependency. New entries focus on delayed consequences, information revelation, and social fallout without urgency framing. Tags emphasized: information, opportunity, social_friction, consequence, terrain. All entries exclude time_pressure tag and use severity bands 1-5 (primarily 1-3). Entries include: scars/lasting toll, credit misplacement, debt incurred, routes changed, word spreading, unexpected witnesses, resource exhaustion, and power balance shifts. Expected to reduce time_pressure frequency in Aftermath from ~60% to ~40% while increasing information/opportunity/social tag presence. No engine changes required. (commit 6651bdc)
- **Campaign mode execution for multi-scene rhythm validation** - Added new "campaign" execution mode to scenario runner that maintains a single shared EngineState across an ordered sequence of scenes. Enables validation of longitudinal narrative rhythm (escalation â†’ release â†’ recovery â†’ renewed tension) across multiple scenes without requiring campaign-level rules. Scenarios specify `"execution_mode": "campaign"` with ordered `scene_sequence` array defining preset/phase/rarity_mode per scene. Each scene executes sequentially with state carry-forward, allowing observation of tension/heat clock evolution, tag cooldown patterns, and severity trends over time. Report includes per-scene state snapshots (tension_clock, heat_clock, cooldown counts) and ordered metrics for rhythm analysis. Created two built-in campaign scenarios: Campaign Rhythm - Normal Mode and Campaign Rhythm - Spiky Mode (6-scene sequences with 2 full approach/engage/aftermath cycles, using same seed for comparison). Matrix mode remains default for backward compatibility. See docs/REQUIREMENTS_json_scenario_import_export.md for complete schema and docs/CAMPAIGN_RHYTHM_RUNNER_DESIGN.md for design rationale.
- **Random seed support for scenarios** - Added ability to use random seeds in both UI and JSON scenarios using Python's Mersenne Twister algorithm (via `random.randint()`). Base seed field now accepts either integer values (for reproducible testing) or string "random" (for pseudorandom generation). UI includes dice button (ðŸŽ²) for easy random seed generation with truly varied values. JSON scenarios can specify `"base_seed": "random"` in template. Each run within a scenario still gets deterministic offset (base_seed + run_index) for reproducibility of individual runs. Mersenne Twister provides high-quality pseudorandom numbers across full range (0-999,999,999) for varied testing scenarios.

### Fixed
- **Scenario basename update on library selection** - Fixed filename not updating when switching between library scenarios. Now properly resets `output_path_manually_edited` flag when loading a new scenario, allowing basename to update to match selected scenario (e.g., switching from Normal to Spiky now updates filename from "...normal..." to "...spiky..."). Manual edits still persist correctly when user explicitly changes the path. (commit a2b9d86)
- **Path sanitization for scenario output** - Fixed nested directory creation from scenario names containing path separators. Added `sanitize_path()` function that splits full paths into directory/basename/extension components, sanitizes only the basename to remove problematic characters (/, \, (), commas, etc.), then reconstructs clean paths. Applied sanitization to all paths loaded from config on startup. Prevents paths like "presets_x_approach/engage/aftermath_x_normal..." from creating unintended subdirectories. (commit aa18ffe)
- **Scenario filename generation improvements** - Fixed two issues with automatic filename generation for JSON scenario exports: (1) Added `sanitize_basename()` function to properly clean path separators (/, \) from scenario names and output_basename fields, preventing unwanted subdirectory creation. (2) Fixed Streamlit widget state conflict warning by reordering session state updates to occur before widget creation. Filenames now properly sanitize characters like "/" into "_" (e.g., "Scenario A/B" becomes "scenario_a_b_TIMESTAMP.json") and update cleanly when switching between scenarios without warnings.
- **Cutoff tuning v2: Morphology-sensitive cap compression** - Enhanced Spiky mode with graduated cap reductions based on morphology score. High-morphology environments (tight spaces, poor visibility, low connectivity) now compress severity caps more aggressively, increasing cutoff frequency to target ranges: 5-10% for dungeon/ruins, 2-5% for wilderness. Implementation uses two-threshold system (morph >= 0.9: -1 cap, morph >= 1.4: -2 cap) to treat structural fragility as a cutoff multiplier while preserving Normal/Calm behavior.
- **Adaptive weighting validation** - Validated adaptive weighting system effectiveness across all presets/modes. Enhanced penalty curve (v0.1 -> v0.2) with tiered recency penalties achieves target variety: dungeon/ruins max 14.5% (exceeds 15% stretch goal), wilderness 27.5% (within structural content limit). Comprehensive test suite added with severity band analysis tooling to diagnose content gaps vs implementation issues.
- **Aftermath phase content expansion** - Added 10 minimal aftermath entries to address phase coverage gaps. Wilderness aftermath expanded from 3 to 6 events with non-attrition diversity (information, visibility, terrain tags). Sea aftermath added 2 dedicated entries. City, ruins, dungeon received 1-2 aftermath entries each. All entries use low severity bands (1-6) appropriate for aftermath consequences. Enables Presets Ã— (Approach/Engage/Aftermath) Ã— Normal suite completion at batch size 200.
- **JSON scenario import/export system with unified save/export UX** - Added JSON-based scenario definition, import, and execution with automatic result export. Users can upload custom scenario JSON files or select from built-in library (scenarios/ directory). Scenarios define presets, phases, rarity modes, batch size, seed, and other parameters. Unified all three save/export operations (Save Report Markdown, Save Report JSON, Save as Template) to use consistent interface: working directory display for path clarity, path specification with cross-session persistence (survives app restarts via `.streamlit_harness_config.json`), and descriptive default filenames with timestamps. "Run and Save Scenario" executes and saves results to user-specified path. "Save as Template" exports current hardcoded suite UI settings as JSON scenario. All operations use shared save_report_to_path() backend (no code duplication). Persistent config file excluded from git to keep personal preferences local. Schema includes `schema_version` field (v1.0) for future-proofing and optional `output_basename` for clean multi-file exports. Includes 2 built-in phase validation scenarios (Normal and Spiky modes) plus comprehensive template file with inline documentation and examples. Enables reproducible validation workflows, automated testing, and ad-hoc scenario creation from UI state. See docs/REQUIREMENTS_json_scenario_import_export.md for complete schema and usage.

### Fixed
- **Critical: Cooldown accumulation bug** - Modified `run_batch()` in `streamlit_harness/app.py` to always tick by at least 1 between events, preventing indefinite cooldown accumulation that caused content pool exhaustion. Without this fix, batches would fail with "No content entries available" error after 5-10 events.
- Added comprehensive root cause analysis in `docs/ROOT_CAUSE_ANALYSIS_content_availability.md`

### Changed
- **Repository file versioning cleanup** - Removed version numbers from filenames, moved version info to file headers. Consolidated duplicate versioned files: `IMPLEMENTATION_REPORT_cutoff_tuning_v2.md` merged into `IMPLEMENTATION_REPORT_cutoff_tuning.md` with version history header, `Streamlit_Harness_v0.1_Requirements_Architecture.md` renamed to `Streamlit_Harness_Requirements_Architecture.md`, `data/core_complications_v0_1.json` renamed to `data/core_complications.json` with versioning tracked in `data/README.md`. All code references updated. Future versioning will use header comments instead of filename suffixes.

### Added  
- Integration tests in `tests/test_cooldown_fix.py` to verify cooldown system functions correctly with minimum ticking
- `data/README.md` - Content pack version history and design principles documentation

## 0.1.x â€“ Streamlit Harness v0.1 Prototype Added

- Refactored Streamlit harness session state into a single HarnessState dataclass to prevent rerun scoping regressions.

- Clamped clocks in state application to a configurable range (default 0â€“12).
- Added adaptive weighting to reduce sticky outcomes (penalize recently used event_ids).
- Cutoff cap is now influenced by rarity mode (spiky lowers cap), harness diagnostics show cutoff resolution breakdown.

- Added Scenario Runner tab (multi-run suites) with downloadable Markdown/JSON debug reports for tuning.

- Harness batch runs tick cooldowns between generated events by default to avoid exhausting the content pool.

- Added a debug-first Streamlit harness (`streamlit_harness/app.py`) to exercise the engine and visualize diagnostics (severity distribution, cutoff rate, tag/event frequencies).
- Kept engine core UI-agnostic, harness is a separate layer that calls into `spar_engine`.
- Updated README with Streamlit harness install/run instructions.
- Added `/docs/KEY_DOCS.md` to help collaborators find the governing docs.
- Packaging hygiene: removed `.git` and `.DS_Store` from the distributed zip artifact.

All notable changes to this project are documented here.
